<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Understanding TypeScript</title>
    <link href="assets/css/bootstrap.css" rel="stylesheet" />
    <!-- Custom styles for this template -->
    <link href="assets/css/starter-template.css" rel="stylesheet" />
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=css&amp;skin=sunburst"></script>
    <style type="text/css">
      html {
        font-size: 90%;
      }

      h2 {
        margin-top: 60px;
      }

      h4,
      h3 {
        padding-top: 40px!;
      }

      p {
        font-size: 1.2em;
      }
      h4 {
        font-size: 1.4em;
      }

      img,
      pre.prettyprint {
        margin-top: 1.5em;
        margin-bottom: 1.5em;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        color: #007bff;
      }
      blockquote {
        border-left: 4px solid #999;
        padding-left: 1rem;
        page-break-inside: avoid;
      }
    </style>
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-primary">
        <div class="container">
          <a class="navbar-brand" href="#">Understanding TypeScript - 2021</a>
          <button
            class="navbar-toggler"
            type="button"
            data-toggle="collapse"
            data-target="#navbarCollapse"
            aria-controls="navbarCollapse"
            aria-expanded="false"
            aria-label="Toggle navigation"
          >
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav mr-auto">
              <li class="nav-item">
                <a class="nav-link" href="#">Home</a>
              </li>
              <li class="nav-item active">
                <a class="nav-link" href="#"
                  >02 - TypeScript basics
                  <span class="sr-only">(current)</span></a
                >
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#">About</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
    </header>
    <div class="container">
      <div class="starter-template">
        <h1 id="typescript-basics--basic-types">
          TypeScript basics &amp; basic types
        </h1>
        <p>
          <strong>Note:</strong> I created a working folder named
          <em>TypeScript-basics-&amp;-basic-types</em> and found that TypeScript
          wasn't working at all. The <strong>&amp;</strong> really caused
          problems so I will watch out for this in the future.
        </p>
        <h2 id="using-types">Using types</h2>
        <p>
          <img
            src="assets/images/core-types.jpg"
            alt="Core types"
            title="Core types"
          />
        </p>
        <h3 id="numbers">Numbers</h3>
        <pre class="prettyprint">
    const add = (n1: number, n2: number) =&gt; {
      return n1 + n2;
    }

    const number1 = 5;
    const number2 = 2.8;

    const result = add(number1, number2);
    console.log(result);
</pre
        >
        <blockquote>
          <p>7.8</p>
        </blockquote>
        <p>
          <strong>Note:</strong> my TypeScript seems to be stricter than the
          video version. In my case I had to add type assignment to the function
          parameters. If I don't do this I get an error because the type is
          <code>any</code>.
        </p>
        <p>
          <strong>Note:</strong> TypeScript's type system only helps you during
          development (before you compile). It does not change your runtime
          code.
        </p>
        <h2 id="typescript-types-versus-javascript-types">
          TypeScript types versus JavaScript types
        </h2>
        <p>
          In JavaScript we can add error checking to make sure that the user
          isn't using values that aren't numbers.
        </p>
        <pre class="prettyprint">
    const add = (n1, n2) =&gt; {
      if (typeof n1 !== 'number' || typeof n2 !== 'number') {
            throw new Error('Incorrect input...');
      }

      return n1 + n2;
    }
</pre
        >
        <p>
          This can be avoided if we are using TypeScript and is redundant work.
          When we are working in JavaScript you are continually using defensive
          programming like the code above to avoid errors. TypeScript frees us
          from this burden.
        </p>
        <p>
          <strong>Note:</strong> TypeScript causes us to fail during
          development, not at runtime.
        </p>
        <p>
          Another interesting point is that JavaScript only knows about a small
          amount of types but Typescript has a lot more types.
        </p>
        <h2 id="typecasting">Typecasting</h2>
        <p>
          <img
            src="assets/images/typecasting.jpg"
            alt="Typecasting"
            title="Typecasting"
          />
        </p>
        <h3 id="booleans">Booleans</h3>
        <pre class="prettyprint">
    const add = (n1: number, n2: number, showResult: boolean) =&gt; {
      if (showResult) {
        console.log(n1 + n2);
      } else {
        return n1 + n2;
      }
    }

    const number1 = 5;
    const number2 = 2.8;
    const printResult = true;

    add(number1, number2, printResult);
</pre
        >
        <blockquote>
          <p>7.8</p>
        </blockquote>
        <p>
          If we change <code>printResult</code> to <em>false</em> no result will
          be printed out.
        </p>
        <h3 id="strings">Strings</h3>
        <pre class="prettyprint">
    const add = (n1: number, n2: number, showResult: boolean, phrase: string) =&gt; {
      if (showResult) {
        console.log(phrase + n1 + n2);
      } else {
        return n1 + n2;
      }
    }

    const number1 = 5;
    const number2 = 2.8;
    const printResult = true;
    const phraseString = 'Result is: ';

    add(number1, number2, printResult, phraseString);
</pre
        >
        <blockquote>
          <p>Result is: 52.8</p>
        </blockquote>
        <p>
          <strong>Note:</strong> we have introduced an error into our code and
          TypeScript doesn't pick up this error.
        </p>
        <p>
          <strong>Important:</strong> be careful joining different types into a
          string.
        </p>
        <p>For defensive coding we will have to add.</p>
        <pre class="prettyprint">
    const add = (n1: number, n2: number, showResult: boolean, phrase: string) =&gt; {
      const result = n1 + n2;
      if (showResult) {
        console.log(phrase + result);
      } else {
        return result;
      }
    }
</pre
        >
        <blockquote>
          <p>Result is: 7.8</p>
        </blockquote>
        <h2 id="type-assignment--type-inference">
          Type Assignment &amp; Type Inference
        </h2>
        <p>
          In this example we use <strong>type assignment</strong> to specify the
          parameter types.
        </p>
        <pre class="prettyprint">
    const add = (n1: number, n2: number, showResult: boolean, phrase: string) =&gt; {
</pre
        >
        <p>Why don't we do this for variable assignment?</p>
        <pre class="prettyprint">
    const number1 = 5;
    const number2 = 2.8;
    const printResult = true;
    const phraseString = 'Result is: ';
</pre
        >
        <p>
          In this case we are using <strong>type inference</strong> to infer the
          types.
        </p>
        <p>
          <code>number1</code> infers a number and this will never change in
          typescript.
        </p>
        <p><code>printResult</code> will always infer a boolean.</p>
        <p><code>phraseString</code> will always infer a string.</p>
        <p>We could assign a type to a variable.</p>
        <pre class="prettyprint">
    let number1: number = 5;
</pre
        >
        <p>
          This is considered bad programming practice and shouldn't be used.
        </p>
        <p>
          It could be used to assign a type to a variable that doesn't have a
          value.
        </p>
        <pre class="prettyprint">
    let number1: number;
</pre
        >
        <p>
          Later on you would have to give the variable a value and if you don't
          give it a number it will be an error.
        </p>
        <h2 id="object-types">Object types</h2>
        <p>Create an object.</p>
        <pre class="prettyprint">
    const person = {
        firstName: 'Alan',
        age: 68
    }

    console.log(person);
</pre
        >
        <blockquote>
          <p>{firstName: &quot;Alan&quot;, age: 68}</p>
        </blockquote>
        <p>Works as expected.</p>
        <p>
          If I try to extract a property that doesn't exist I will get an error
          in TypeScript.
        </p>
        <pre class="prettyprint">
    console.log(person.nickName);
</pre
        >
        <p>
          TypeScript will warn us that the property hasn't been added to the
          object.
        </p>
        <p>
          If we hover over the person object we will see this in our
          intellisense.
        </p>
        <p>
          <img
            src="assets/images/object-type.jpg"
            alt="Object type"
            title="Object type"
          />
        </p>
        <p>
          This can be confusing. It isn't a JavaScript object as you can see by
          the semicolons at the end of the properties.
        </p>
        <p>
          It is an object type inferred by TypeScript. What we are seeing isn't
          key-value pairs but key-type pairs as inferred by TypeScript.
        </p>
        <p>
          We can change our code to an object type but when we hover over our
          <code>person</code> object in the console statement it only shows us
          that it is an object but doesn't show us our properties. This is a
          generic object and we really want the full details of the object
          showing.
        </p>
        <pre class="prettyprint">
    const person: object = {
        firstName: 'Alan',
        age: 68
    }

    console.log(person);
</pre
        >
        <p>
          If I put a dot (<code>.</code>) after the <code>person</code> I don't
          get any intellisense an if I try to add the
          <code>.firstName</code> property after <code>person</code> I will get
          an error.
        </p>
        <p>
          We can change this to key-value pairs to describe the type of object.
        </p>
        <pre class="prettyprint">
    const person: {
        firstName: string,
        age: number
    } = {
        firstName: 'Alan',
        age: 68
    }

    console.log(person.firstName);
</pre
        >
        <blockquote>
          <p>Alan</p>
        </blockquote>
        <p>
          This will remove the property error and show us the intellisense for
          the <code>person</code> object again.
        </p>
        <p>
          Once again this is not a good practice. We should let TypeScript infer
          the types as we did in the original object.
        </p>
        <h2 id="nested-objects--types">Nested objects &amp; types</h2>
        <p>Of course object types can also be created for nested objects.</p>
        <p>Let's say you have this JavaScript object:</p>
        <pre class="prettyprint">
    const product = {
      id: 'abc1',
      price: 12.99,
      tags: ['great-offer', 'hot-and-new'],
      details: {
        title: 'Red Carpet',
        description: 'A great carpet - almost brand-new!'
      }
    }
</pre
        >
        <p>This would be the type of such an object:</p>
        <pre class="prettyprint">
let product: {
    id: string,
    price: number,
    tags: string[],
    details: {
      title: string,
      description: string
    }
}
</pre
        >
        <p>So you have an object type nested inside of an object type.</p>
        <h2 id="array-types">Array types</h2>
        <pre class="prettyprint">
    const person = {
        firstName: 'Alan',
        age: 68,
        hobbies: ['Programming', 'Walking', 'Reading']
    }

    console.log(person.hobbies);
</pre
        >
        <blockquote>
          <p>
            (3) [&quot;Programming&quot;, &quot;Walking&quot;,
            &quot;Reading&quot;]
          </p>
        </blockquote>
        <p>Once again, if we hover over our hobbies array.</p>
        <p>
          <img
            src="assets/images/string-array.jpg"
            alt="String array"
            title="String array"
          />
        </p>
        <p>
          TypeScript describes our data array as a <code>string[]</code> (array
          of strings).
        </p>
        <p>I can create a standalone string array.</p>
        <pre class="prettyprint">
    let favoriteActivities: string[];
</pre
        >
        <p>
          If I create just a single string for
          <code>favouriteActivites</code> it will be an error
        </p>
        <pre class="prettyprint">
    let favoriteActivities: string[];

    favoriteActivities = 'Music';
</pre
        >
        <p>We must make an array.</p>
        <pre class="prettyprint">
    let favoriteActivities: string[];

    favoriteActivities = ['Music', 'Programming'];

    console.log(favoriteActivities);
</pre
        >
        <blockquote>
          <p>(2) [&quot;Music&quot;, &quot;Programming&quot;]</p>
        </blockquote>
        <p>This also won't work as we have specified an array of strings.</p>
        <pre class="prettyprint">
    favoriteActivities = ['Music', 'Programming', 1];
</pre
        >
        <p>
          You could create a mixed array by specifying the
          <code>any</code> type.
        </p>
        <pre class="prettyprint">
    let jobs: any[];

    jobs = ['Programming', 1];
</pre
        >
        <p>This defeats the purpose of working with TypeScript.</p>
        <p>
          We can also print out the <code>person.hobbies</code> array
          collection.
        </p>
        <pre class="prettyprint">
    const person = {
        firstName: 'Alan',
        age: 68,
        hobbies: ['Programming', 'Walking', 'Reading']
    }

    person.hobbies.forEach(hobby =&gt; {
        console.log(hobby);
    });
</pre
        >
        <blockquote>
          <p>
            Programming<br />
            Walking<br />
            Reading
          </p>
        </blockquote>
        <p>We can also use any string functions on our array of strings.</p>
        <pre class="prettyprint">
    person.hobbies.forEach(hobby =&gt; {
        console.log(hobby.toUpperCase());
    });
</pre
        >
        <blockquote>
          <p>
            PROGRAMMING<br />
            WALKING<br />
            READING
          </p>
        </blockquote>
        <h2 id="tuples">Tuples</h2>
        <p>
          TypeScript adds Tuple types to the core types available. A tupe looks
          like an array but it is different because it is a fixed length array
          (and fixed type).
        </p>
        <pre class="prettyprint">
    const person = {
        firstName: 'Alan',
        age: 68,
        hobbies: ['Programming', 'Walking', 'Reading'],
        role: [2, 'Author']
    }
</pre
        >
        <p>
          <code>role</code> is a tuple. In this case it always has a number in
          the first place and a string in the second place. In fact if you hover
          over <code>role</code> you will see.
        </p>
        <p><img src="assets/images/tuple.jpg" alt="Tuple" title="Tuple" /></p>
        <p>or</p>
        <pre class="prettyprint">
    role: (number | string)[]
</pre
        >
        <p>
          This is a <strong>union</strong> type and we will get into those
          later.
        </p>
        <p>
          The key thing is that typeScript sees this as an array that might hold
          either strings or numbers. The following are also valid;
        </p>
        <pre class="prettyprint">
    person.role.push('Admin');
    person.role = ['Writer', 1];
    person.role = ['Writer', 'Reader'];
</pre
        >
        <p>
          We can make <code>role</code> into a tuple by specifying the
          <code>person</code> object's types.
        </p>
        <pre class="prettyprint">
    const person: {
        firstName: string;
        age: number;
        hobbies: string[];
        role: [number, string];
    } = {
        firstName: 'Alan',
        age: 68,
        hobbies: ['Programming', 'Walking', 'Reading'],
        role: [2, 'Author']
    }

    person.role.forEach(item =&gt; {
        console.log(item);
    });    
</pre
        >
        <blockquote>
          <p>
            2<br />
            Author
          </p>
        </blockquote>
        <p>Now all of the following will be errors..</p>
        <pre class="prettyprint">
    person.role.push('Admin'); // error but not shown as an error
    person.role = ['Writer', 1]; // error, wrong position
    person.role = ['Writer', 'Reader']; // error, no number then string
</pre
        >
        <p>
          The <code>push()</code> statement won't be seen as an error but at
          least TypeScript can pick the bottom two errors.
        </p>
        <p>This would be allowed.</p>
        <pre class="prettyprint">
    person.role = [1, 'Writer'];
</pre
        >
        <p>
          Tuples are really handy where you want a fixed length array. You can't
          use these in JavaScript.
        </p>
        <h2 id="working-with-enums">Working with enums</h2>
        <p>Enums are our first custom type that are added by TypeScript.</p>
        <pre class="prettyprint">
    enum Role { ADMIN, READ_ONLY, AUTHOR };
</pre
        >
        <p>
          Note that the enum variable is usually shown with an uppercase for the
          first letter and all enum values should be uppercase. This is a zero
          based index.
        </p>
        <pre class="prettyprint">
    enum Role { ADMIN, READ_ONLY, AUTHOR };

    const person = {
        firstName: 'Alan',
        age: 68,
        hobbies: ['Programming', 'Walking', 'Reading'],
        role: Role.ADMIN
    }

    if (person.role === Role.ADMIN) {
        console.log('User is an Administrator.');
    }
</pre
        >
        <blockquote>
          <p>User is an Administrator.</p>
        </blockquote>
        <p>
          So an <code>enum</code> assigns labels to numbers. If you hover over
          the values in the <code>enum</code> you will see their number. You can
          also see this in the compiled JavaScript.
        </p>
        <pre class="prettyprint">
    var Role;
    (function (Role) {
        Role[Role[&quot;ADMIN&quot;] = 0] = &quot;ADMIN&quot;;
        Role[Role[&quot;READ_ONLY&quot;] = 1] = &quot;READ_ONLY&quot;;
        Role[Role[&quot;AUTHOR&quot;] = 2] = &quot;AUTHOR&quot;;
    })(Role || (Role = {}));
    ;
    const person = {
        firstName: 'Alan',
        age: 68,
        hobbies: ['Programming', 'Walking', 'Reading'],
        role: Role.ADMIN
    };
    if (person.role === Role.ADMIN) {
        console.log('User is an Administrator.');
    }
</pre
        >
        <p>TypeScript saves us from writing some complex code!</p>
        <p>
          If you don't like the zero based index you can define your own
          numbering system.
        </p>
        <pre class="prettyprint">
    enum Role { ADMIN = 5, READ_ONLY, AUTHOR };
</pre
        >
        <p>Where ADMIN = 5, READ_ONLY = 6 and AUTHOR = 7.</p>
        <p>
          You could also assign your own values to each element in the
          <code>enum</code>.
        </p>
        <p>
          If you wanted to you could even assign a name instead of a number.
        </p>
        <pre class="prettyprint">
    enum Role { ADMIN = 'ADMIN', READ_ONLY = 'READ_ONLY', AUTHOR = 'AUTHOR' };
</pre
        >
        <p>The standard is the zero based enum.</p>
        <h2 id="the-any-type">The 'any' type</h2>
        <p>
          When you use an <code>any</code> type you can use any value you want.
          This defeats the purpose of TypeScript and you want to avoid it if you
          can.
        </p>
        <h2 id="the-union-type">The Union type</h2>
        <p>
          The union type allows us to add one or more types to a variable or
          array.
        </p>
        <p>
          In a variable we can set the type where multiple types could be
          required. In the following example we are saying that the
          <code>uid</code> variable can be either a string or number.
        </p>
        <pre class="prettyprint">
    let uid: string | number;

    uid = 456;
    uid = '123';

    if (typeof uid !== 'number') {
        uid = +uid;
    }

    console.log(`uid's type is ${typeof uid}.`);
    console.log(`The value is ${uid}.`);
</pre
        >
        <blockquote>
          <p>
            uid's type is number.<br />
            The value is 123.
          </p>
        </blockquote>
        <p>
          <strong>Note:</strong> This gives us some flexibility with types but
          we have to be careful when using the variable to make sure we cast it
          to the correct type.
        </p>
        <p>
          Another example of union types is to create an array of mixed types.
        </p>
        <pre class="prettyprint">
    const mixed: (string | number | boolean)[] = [];

    mixed.push('Alan');
    mixed.push(27);
    mixed.push(true);

    mixed.forEach(item =&gt; {
        console.log(item);
    });
</pre
        >
        <blockquote>
          <p>
            Alan<br />
            27<br />
            true
          </p>
        </blockquote>
        <p>
          In our final example we have a simple function to add a couple of
          people's ages.
        </p>
        <pre class="prettyprint">
    const combine = (input1: number, input2: number) =&gt; {
        const result = input1 + input2;
        return result;
    }

    const combinedAges = combine(36, 24);
    console.log(combinedAges);
</pre
        >
        <p>
          This isn't exactly what we want and in this case we want to use
          strings and numbers as input and we actually want to have the option
          to contcatenate two values as well as sum two values.
        </p>
        <p>This is where we could use the <code>union</code> type.</p>
        <pre class="prettyprint">
    const combine = (input1: number | string, input2: number | string) =&gt; {
        const result = input1 + input2;
        return result;
    }

    const combinedAges = combine(36, 24);
    console.log(combinedAges);

    const combinedNames = combine('Alan', 'Charley');
    console.log(combinedNames);
</pre
        >
        <blockquote>
          <p>
            60<br />
            AlanCharley
          </p>
        </blockquote>
        <p>
          We get an error in the code on the result statement but it actually
          works and prints out the results correctly.
        </p>
        <p>We can improve on this code to remove the error.</p>
        <pre class="prettyprint">
    const combine = (input1: number | string, input2: number | string) =&gt; {
        let result;
        if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number') {
            result = input1 + input2;
        } else {
            result = input1.toString() + input2.toString();
        }
        return result;
    }

    const combinedAges = combine(36, 24);
    console.log(combinedAges);

    const combinedNames = combine('Alan', 'Charley');
    console.log(combinedNames);
</pre
        >
        <blockquote>
          <p>
            60<br />
            AlanCharley
          </p>
        </blockquote>
        <p>
          You won't always have to use error checking with union types but
          sometimes you will need to.
        </p>
        <h2 id="literal-types">Literal types</h2>
        <p>
          Union types allow us to set one or more types in an array or variable.
          We can also use multiple literal types.
        </p>
        <p>A simple example.</p>
        <pre class="prettyprint">
    type CardinalDirection = | 'North' | 'East' | 'South' | 'West';
    
    function move(distance: number, direction: CardinalDirection) {
        // ...
    }
    
    move(1, 'North'); // okay
    move(1, 'Nurth'); // error
</pre
        >
        <p>
          Literal types can be used for numbers or strings and are especially
          useful for strings.
        </p>
        <p>
          In our <code>combine()</code> function example above we are expecting
          a string or number type as our input. We could describe this type by
          using a third parameter named <code>resultConversion</code> which we
          describe as a string so we will set it as a type string.
        </p>
        <pre class="prettyprint">
    const combine = (input1: number | string, input2: number | string, resultConversion: string) =&gt; {
        let result;
        if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number' || resultConversion === 'as-number') {
            result = +input1 + +input2;
        } else {
            result = input1.toString() + input2.toString();
        }

        return result;
    }

    const combinedAges = combine(36, 24, 'as-number');
    console.log(combinedAges);

    const combinedStringAges = combine('36', '24', 'as-number');
    console.log(combinedStringAges);

    const combinedNames = combine('Alan', 'Charley', 'as-text');
    console.log(combinedNames);
</pre
        >
        <blockquote>
          <p>
            60<br />
            60<br />
            AlanCharley
          </p>
        </blockquote>
        <p>
          This is working as expected and in our arguments we are using either
          'as-number' or 'as-text'. If we return anything else as a string
          literal we will cause problems in the <code>if</code> test and
          probably not get the correct result.
        </p>
        <p>
          We can use TypeScript to force us to use either of the string literals
          but no other string as input for the third argument.
        </p>
        <p>We can change.</p>
        <pre class="prettyprint">
    resultConversion: string
</pre
        >
        <p>to a literal type.</p>
        <pre class="prettyprint">
    resultConversion: 'as-number' | 'as-text'
</pre
        >
        <p>Now, if we enter the following it will be an error.</p>
        <pre class="prettyprint">
    const combinedStringAges = combine('36', '24', 'as-numb'); // error
</pre
        >
        <h2 id="type-aliases---custom-types">Type aliases - Custom types</h2>
        <p>We can create our own type aliases (<code>Combinable</code>).</p>
        <pre class="prettyprint">
    type Combinable = number | string;

    const combine = (input1: Combinable, input2: Combinable, resultConversion: 'as-number' | 'as-text') =&gt; {
</pre
        >
        <p>
          We can also create custom types (<code>ConversionDescriptor</code>).
        </p>
        <pre class="prettyprint">
type Combinable = number | string;
type ConversionDescriptor = 'as-number' | 'as-text';

const combine = (input1: Combinable, input2: Combinable, resultConversion: ConversionDescriptor) =&gt; {
</pre
        >
        <p>
          The end result of using type aliases and custom types is that our
          parameter variables are much cleaner looking and it saves us some
          typing.
        </p>
        <p>
          When we compile we end up with the following complicated piece of
          JavaScript that TypeScript saves us having to create.
        </p>
        <h4 id="javascript">JavaScript</h4>
        <pre class="prettyprint">
    const combine = (input1, input2, resultConversion) =&gt; {
        let result;
        if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number' || resultConversion === 'as-number') {
            result = +input1 + +input2;
        }
        else {
            result = input1.toString() + input2.toString();
        }
        return result;
    };
</pre
        >
        <p>The completed <code>combine()</code> function.</p>
        <pre class="prettyprint">
    type Combinable = number | string;
    type ConversionDescriptor = 'as-number' | 'as-text';

    const combine = (input1: Combinable, input2: Combinable, resultConversion: ConversionDescriptor) =&gt; {
        let result;
        if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number' || resultConversion === 'as-number') {
            result = +input1 + +input2;
        } else {
            result = input1.toString() + input2.toString();
        }

        return result;
    }

    const combinedAges = combine(36, 24, 'as-number');
    console.log(combinedAges);

    const combinedStringAges = combine('36', '24', 'as-number');
    console.log(combinedStringAges);

    const combinedNames = combine('Alan', 'Charley', 'as-text');
    console.log(combinedNames);
</pre
        >
        <h2 id="type-aliases-and-object-types">
          Type Aliases and Object types
        </h2>
        <p>
          Type aliases can be used to create your own types. You are not limited
          to using union types though - you can also provide an alias to a
          complex object type.
        </p>
        <p>The following routine is not using type aliases.</p>
        <pre class="prettyprint">
    const greet = (user: { name: string; age: number }) =&gt; {
        console.log('Hi, I am ' + user.name);
    }

    const isOlder = (user: { name: string; age: number }, checkAge: number) =&gt; {
        return checkAge &lt;= user.age;
    }

    const u1 = { name: 'James', age: 14 };
    const votingAge = 18;

    greet(u1);

    const ofAge = isOlder(u1, votingAge);

    if (ofAge) {
        console.log(`${u1.name} is of voting age.`);
    } else {
        console.log(`${u1.name} is too young to vote.`);
    }
</pre
        >
        <blockquote>
          <p>
            Hi, I am James<br />
            James is too young to vote.
          </p>
        </blockquote>
        <p>
          We can add type aliases to reduce the amount of typing we do. In the
          previous example we could have created the following type alias for an
          object type.
        </p>
        <pre class="prettyprint">
    type User = { name: string; age: number };
</pre
        >
        <p>Adding this to the previous example would now look like this.</p>
        <pre class="prettyprint">
    type User = { name: string; age: number };

    const greet = (user: User) =&gt; {
        console.log('Hi, I am ' + user.name);
    }

    const isOlder = (user: User, checkAge: number) =&gt; {
        return checkAge &lt;= user.age;
    }

    const u1: User = { name: 'James', age: 14 };
    const votingAge = 18;

    greet(u1);

    const ofAge = isOlder(u1, votingAge);

    if (ofAge) {
        console.log(`${u1.name} is of voting age.`);
    } else {
        console.log(`${u1.name} is too young to vote.`);
    }
</pre
        >
        <blockquote>
          <p>
            Hi, I am James<br />
            James is too young to vote.
          </p>
        </blockquote>
        <p>This makes the parameters in both functions look cleaner.</p>
        <h4 id="quiz">Quiz</h4>
        <p>Will this code make it through compilation?</p>
        <pre class="prettyprint">
    type User = { name: string } | string;
    let u1: User = {name: 'Max'};
    u1 = 'Michael';
</pre
        >
        <blockquote>
          <p>
            This code is fine. The union type allows either an object (with a
            &quot;name&quot; property) OR a string. You can switch values how
            often you want.
          </p>
        </blockquote>
        <h2 id="function-return-types--%22void%22">
          Function Return Types &amp; &quot;void&quot;
        </h2>
        <p>
          If you have a function you can hover over the function name and it
          will show you the return type.
        </p>
        <pre class="prettyprint">
    const add = (num1: number, num2: number) =&gt; {
        return num1 + num2;
    }
</pre
        >
        <p>Hovering over the function name produces this message.</p>
        <p>
          <img
            src="assets/images/function-return-type.jpg"
            alt="Function return type"
            title="Function return type"
          />
        </p>
        <p>
          So TypeScript infers the return type from the return statement
          variables.
        </p>
        <p>
          What if the function doesn't have a return value? TypeScript has a
          special type that is returned in this case and it is a type of
          <code>void</code>.
        </p>
        <pre class="prettyprint">
    const printResult = (num: number) =&gt; {
        console.log(`Result: ${num}`);
    }
</pre
        >
        <p>
          This function doesn't have a return type and you can actually add a
          return type to the function if you want. In the case of no return
          value TypeScript gives us the return type of <code>void</code>.
        </p>
        <pre class="prettyprint">
    const printResult = (num: number): void =&gt; {
        console.log(`Result: ${num}`);
    }
</pre
        >
        <p>
          In most cases this isn't necessary because TypeScript infers the type
          value.
        </p>
        <pre class="prettyprint">
    const add = (num1: number, num2: number) =&gt; {
        return num1 + num2;
    }

    const printResult = (num: number): void =&gt; {
        console.log(`Result: ${num}`);
    }

    printResult(add(7, 16));
</pre
        >
        <blockquote>
          <p>Result: 23</p>
        </blockquote>
        <p>
          If you hover over the <code>printResult()</code> function you will get
          a <code>void</code> return type.
        </p>
        <p>
          <img
            src="assets/images/void-return-type.jpg"
            alt="Void return type"
            title="Void return type"
          />
        </p>
        <h2 id="functions-as-types">Functions as Types</h2>
        <p>
          In JavaScript we can create a new variable that can take a function.
        </p>
        <pre class="prettyprint">
    let combinedValues;

    combinedValues = add;

    console.log(combinedValues(8, 8));
</pre
        >
        <p>
          <code>combinedValues</code> becomes equal to the function
          <strong>add()</strong>
        </p>
        <p>
          So we can run combinedValues to add two numbers together. this works
          fine but there can be an issue in TypeScript.
        </p>
        <pre class="prettyprint">
let combinedValues;

combinedValues = add;
combinedValues = 5;

console.log(combinedValues(8, 8));
</pre
        >
        <p>
          In some cases this will cause and error in the
          <code>console.log()</code> statement. In other cases this won't even
          produce an error until you run the program in the browser.
        </p>
        <p>
          This is something we want to guard against and TypeScript can help us
          by allowing us to cast the <code>combinedValues</code> variable as a
          function
        </p>
        <pre class="prettyprint">
    let combinedValues: Function;

    combinedValues = add;
    combinedValues = 5;

    console.log(combinedValues(8, 8));
</pre
        >
        <p>
          Now, <em>combinedValues = 5;</em> will show up as an error and if we
          compiled we would get a compilation error.
        </p>
        <p>
          There could still be an issue with our code that we need to be aware
          of.
        </p>
        <pre class="prettyprint">
let combinedValues: Function;

combinedValues = add;
combinedValues = printResult;

console.log(combinedValues(8, 8));
</pre
        >
        <blockquote>
          <p>undefined</p>
        </blockquote>
        <p>
          This code is perfectly legal and will compile because
          <code>printResult()</code> is a valid function. The problem is that it
          doesn't have two arguments so will run in the browser and produce an
          <em>undefined</em> result.
        </p>
        <p>
          It would be good if TypeScript could warn us. This is where function
          types come into play.
        </p>
        <p>
          Function types are types that describe a function's parameters and the
          return value of that function.
        </p>
        <pre class="prettyprint">
    let combinedValues: (a: number, b: number) =&gt; number;

    combinedValues = add;
    combinedValues = printResult;

    console.log(combinedValues(8, 8));
</pre
        >
        <p>
          Now <code>combinedValues = printResult;</code> will produce an error.
        </p>
        <p>
          TypeScript is saying here that <code>combinedValues()</code> has to be
          a function having two number parameters and a number as a return type.
          The <code>add()</code> satisfies this criteria.
        </p>
        <h2 id="function-types--callbacks">Function Types &amp; Callbacks</h2>
        <p>Functions with callbacks work the same way as function types.</p>
        <pre class="prettyprint">
    const addAndHandle = (n1: number, n2: number, cb: (num: number) =&gt; void) =&gt; {
        const result = n1 + n2;

        cb(result);
    }

    addAndHandle(10, 20, (result) =&gt; {
        console.log(result);
    });
</pre
        >
        <blockquote>
          <p>30</p>
        </blockquote>
        <p>
          In the function we are using a callback function as a parameter that
          has a single parameter and returns a void.
        </p>
        <p>
          Once we have created our function we can call it and in the callback
          function we can log the result.
        </p>
        <p>
          Another interesting fact is that in our function call if we decide to
          return a value TypeScript will allow this even though we have
          specified a return type of <code>void</code>.
        </p>
        <p>
          This is not an error and you will be able to use the return value.
        </p>
        <pre class="prettyprint">
    const addAndHandle = (n1: number, n2: number, cb: (num: number) =&gt; void) =&gt; {
        const result = n1 + n2;

        return cb(result);
    }

    const returnValue = addAndHandle(10, 20, (result) =&gt; {
        console.log(result);
        return result;
    });

    console.log(returnValue);
</pre
        >
        <blockquote>
          <p>
            30<br />
            30
          </p>
        </blockquote>
        <h4 id="quiz">quiz</h4>
        <p>Will this code compile?</p>
        <pre class="prettyprint">
    function sendRequest(data: string, cb: (response: any) =&gt; void) {
      // ... sending a request with &quot;data&quot;
      return cb({data: 'Hi there!'});
    }
    
    sendRequest('Send this!', (response) =&gt; { 
      console.log(response);
      return true;
    });
</pre
        >
        <blockquote>
          <p>
            Yes, callback functions can return something, even if the argument
            on which they're passed does NOT expect a returned value.
          </p>
        </blockquote>
        <h2 id="the-%22unknown%22-type">The &quot;unknown&quot; Type</h2>
        <pre class="prettyprint">
    let userInput: unknown;
</pre
        >
        <p>
          It might be unknown because the user doesn't know what type it will
          be.
        </p>
        <p>
          The interesting thing is that we can store any type of value and we
          won't get any errors.
        </p>
        <pre class="prettyprint">
let userInput: unknown;

userInput = 5;
userInput = 'Alan';
console.log(userInput);
</pre
        >
        <p>
          This is the same as not setting a type or if we used the type of
          <code>any</code> but <code>unknown</code> is different.
        </p>
        <pre class="prettyprint">
let userInput: unknown;
let userName: string;

userInput = 5;
userInput = 'Alan';

userName = userInput;
</pre
        >
        <p>
          This will cause an error on the final line of code. We can't let
          <code>userName</code> = <code>userInput</code> because it is of type
          <strong>unknown</strong>.
        </p>
        <p>
          <img
            src="assets/images/unknown-error.jpg"
            alt="Unknown error"
            title="Unknown error"
          />
        </p>
        <p>
          If we changed <code>userInput</code> type to <code>any</code> the code
          would work because <code>any</code> basically says &quot;do whatever
          you want!&quot;.
        </p>
        <p>
          With <code>unknown</code> we first have to check the type before we go
          ahead and try to assign <code>userInput</code> to unserName``.
        </p>
        <p>This code will work.</p>
        <pre class="prettyprint">
    if (typeof userInput === 'string') {
        userName = userInput;
        console.log(userName);
    }
</pre
        >
        <p>The interesting thing is that the following won't work.</p>
        <pre class="prettyprint">
    if (typeof userInput === 'string') {
        userName = userInput;
    }

    console.log(userName); // error
</pre
        >
        <p>the <code>console.log()</code> statement in this case will fail.</p>
        <h2 id="the-%22never%22-type">The &quot;never&quot; Type</h2>
        <p>Can be used in functions instead of <code>void</code>.</p>
        <pre class="prettyprint">
    const generateError = (message: string, code: number) =&gt; {
        throw { message: message, code: code };
    }

    generateError('An error occurred!', 500);
</pre
        >
        <blockquote>
          <p>Uncaught {message: &quot;An error occurred!&quot;, code: 500}</p>
        </blockquote>
        <p>
          This may look abstract but it could be used in large applications
          where you don't want to manually throw an error but you could pass in
          a message and code to produce an error message.
        </p>
        <p>
          If you hover over the function name you will find that it returns the
          <code>never</code> type. This function never produces a return value.
          The <code>throw</code> call technically causes our script to crash and
          even if we tried to return a value it wouldn't happen.
        </p>
        <p>
          You can be clear and explicitly set <code>never</code> as a return
          type.
        </p>
        <pre class="prettyprint">
    const generateError = (message: string, code: number): never =&gt; {
        throw { message: message, code: code };
    }

    generateError('An error occurred!', 500);
</pre
        >
      </div>
      <!-- starter-template -->
    </div>
    <!-- /.container -->

    <!-- Bootstrap core JavaScript
================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" />
    <script>
      hljs.initHighlightingOnLoad();
    </script>

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/bootstrap.min.js"></script>
  </body>
</html>
